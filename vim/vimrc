" {{{ 1 important
" compatible: set (nocp|cp)
" behave very Vi compatible (not advisable)
set nocp

" runtimepath
" list of directories used for runtime files and plugins
set rtp+=~/dotfiles/vim,~/dotfiles/vim/after

" necessary on some Linux distros for pathogen to properly load bundles
filetype off

" Load pathogen managed plugins
call pathogen#runtime_append_all_bundles()
call pathogen#helptags()

" Enable filetype
filetype on
filetype plugin on
filetype indent on

" With a map leader it's possible to do extra key combinations
" like <leader>w saves the current file
let mapleader = ","
let g:mapleader = ","
" }}}

" {{{ 2 moving around, searching and patterns
" whichwrap
" list of flags specifying which commands wrap to another line (local to window)
set ww+=<,>,h,l

" ignorecase: set (noic|ic)
" ignore case when using a search pattern
set ic

" incsearch set (nois|is)
" show match for partly typed search command
set is

" magic: set (magic|nomagic)
" change the way backslashes are used in search patterns
set magic
" }}}

" {{{ 4 displaying text
" Active syntax
syntax on

" scroll
" number of lines to scroll for CTRL-U and CTRL-D (local to window)
set scr=9

" scrolloff: set so=([0-9]+)
" number of screen lines to show around the cursor
set so=3

" cmdheight: set ch=([0-9]+)
" number of lines used for the command-line
set ch=1

" list: set (nolist|list)
" show <Tab> as ^I and end-of-line as $ (local to window)
set list

" listchars list of strings used for list mode
set listchars=tab:▸\ ,eol:¬

" number: set (nu|nonu)
" show the line number for each line (local to window)
set nu

" wrap: set (wrap|nowrap)
" long lines wrap
set wrap

" sidescroll: set ss=[0-9]+
" minimal number of columns to scroll horizontally
set ss=0

" linebreak: set (nolbr|lbr)
" wrap long lines at a character in 'breakat' (local to window)
set lbr

" breakat
" which characters might cause a line break
set brk=\ \	-+;,/?\&

" showbreak
" string to put before wrapped screen lines
set sbr=
" }}}

" {{{ 5 syntax, highlighting and spelling
" background "dark" or "light"; the background color brightness
set bg=light

" solarized
let g:solarized_termcolors=256
let g:solarized_visibility="low"
colorscheme solarized

" hlsearch set (nohls|hls)
" highlight all matches for the last used search pattern
set hls
map <silent> <leader><cr> :noh<cr>


" cursorline set (nocul|cul)
" highlight the screen line of the cursor (local to window)
set nocul

" Spell
map ,pt :set spell spelllang=pt<cr>
map ,en :set spell spelllang=en<cr>
map ,ns :set nospell<cr>
" }}}

" {{{ 6 multiple windows
" laststatus: set ls=[0-2]
" when to use a status line for the last window
set ls=2

" statusline
" alternate format to be used for a status line
set stl+=\[FILE=%{&ff}\|%{&enc}\|%Y]
set stl+=\[POS=%l,%c\|%L\|%P]
set stl+=\[ASCII=%03.3b]
set stl+=\[HEX=%02.2B]
set stl+=[GIT=%{GitBranch()}]
set stl+=\[F=%{foldlevel('.')}]

" hidden: set (nohi|dhid)
" don't unload a buffer when no longer shown in a window
set hid
" }}}

" {{{ 7 multiple tab pages
" tabpagemax: set tpm=([0-9]+)
" maximum number of tab pages to open for -p and "tab all"
set tpm=1000
" }}}

" {{{ 8 terminal
" term set term=xterm
" name of the used terminal
set term=xterm

" Colors
set t_Co=256

" ttyfast set (tf|notf)
" terminal connection is fast
set tf
" }}}

" {{{ 9 using the mouse
" mouse
" list of flags for using the mouse
set mouse=a

" mousefocus: set (nomousef|mousef)
" the window with the mouse pointer becomes the current one
set mousef

" ttymouse "xterm", "xterm2", "dec" or "netterm"; type of mouse
set ttym=xterm2
" }}}

" {{{ 12 messages and info
" showcmd: set (nosc|sc)
" show (partial) command keys in the status line
set sc

" showmode: set (smd|nosmd)
" display the current mode in the status line
set smd

" report
" threshold for reporting number of changed lines
set report=2

" visualbell set (novb|vb)
" use a visual bell instead of beeping
set novb
" }}}

" {{{ 14 editing text
" backspace
" specifies what <BS>, CTRL-W, etc. can do in Insert mode
set bs=indent,eol,start

" formatoptions
" list of flags that tell how automatic formatting works (local to buffe)
"set fo-=o
set fo=croqln21

" wrapmargin
" margin from the right in which to break a line (local to buffer)
set wm=0

" complete
" specifies how Insert mode completion works for CTRL-N and CTRL-P (local to buffer)
set cpt=.,w,k,b,u,t,i cpt-=k cpt+=k

" matchtime: set mat=([0-9]|10)
" tenth of a second to show a match for 'showmatch'
set mat=5

" matchpairs
" list of pairs that match for the "%" command (local to buffer)
" Plugin which enhances this feature: ~/.vim/bundle/matchit
set mps=(:),{:},[:],<:>
" }}}

" {{{ 15 tabs and indenting
" tabstop: set ts=([0-9]+)
" number of spaces a <Tab> in the text stands for (local to buffer)
set ts=4

" shiftwidth: set sw=([0-9]+)
" number of spaces used for each step of (auto)indent (local to buffer)
set sw=4

" expandtab: set noet et
" expand <Tab> to spaces in Insert mode (local to buffer)
set noet

" autoindent: set (noai|ai)
" automatically set the indent of a new line (local to buffer)
set ai

" smartindent: set (nosi|si)
" do clever autoindenting (local to buffer)
set nosi

" cindent: set (nocin|cin)
" enable specific indenting for C code (local to buffer)
set cin

" copyindent: set (noci|ci)
" copy whitespace for indenting from previous line (local to buffer)
set noci

" preserveindent: set (nopi|pi)
" preserve kind of whitespace when changing indent (local to buffer)
set nopi
" }}}

" {{{ 16 folding: set (fen|nofen)
" foldenable
" set to display all folds open (local to window)
set fen

" foldmarker
" markers used when 'foldmethod' is "marker" (local to window)
set fmr={{{,}}}

" foldmethod
" folding type: "manual", "indent", "expr", "marker" or "syntax" (local to window)
set fdm=manual

" foldnestmax: set fdn=20
" maximum fold depth for when 'foldmethod is "indent" or "syntax" (local to window)
set fdn=3
" }}}

" {{{ 19 reading and writing files
" modeline: set (ml|noml)
" enable using settings from modelines when reading a file (local to buffer)
set ml

" modelines: set mls=[0-9]+
" number of lines to check for modelines
set mls=5

" fileformat
" end-of-line format: "dos", "unix" or "mac" (local to buffer)
set ff=unix

" fileformats
" list of file formats to look for when editing a file
set ffs=unix,mac,dos

" autowrite: set (noaw|aw)
" automatically write a file when leaving a modified buffer
set aw

" backup: set (nobk|bk)
" keep a backup after overwriting a file
set nobk

" backupskip
" patterns that specify for which files a backup is not made
set bsk=~/.tmp/*

" backupdir
" list of directories to put backup files in
set bdir=~/.tmp

" autoread: set (noar|ar)
" automatically read a file when it was modified outside of Vim (global or local to buffer)
set ar
" }}}

" {{{ 20 the swap file
" directory
" list of directories for the swap file
set dir=~/.vim/tmp

" swapfile: set (swf|noswf)
" use a swap file for this buffer (local to buffer)
set noswf

" updatecount
" number of characters typed to cause a swap file update
set uc=50

" updatetime
" time in msec after which the swap file will be updated
set ut=4000
" }}}

" {{{ 21 command line editing
" history
" how many command lines are remembered
set hi=1000

" wildmode
" specifies how command line completion works
set wim=longest,list

" wildignore
" list of patterns to ignore files for file name completion
set wig+=*.o,*.o.*,*.a,*.i,*.obj,*.bak,*.exe,.dll,*.com,*.class,*.au,*.djvu,*.pdf,*.chm,/*.mkv,*.ttf,*.TTF,*.db
set wig+=*.wav,*.ps,*.avi,*.wmv,*.flv,*.dvi,*.rmvb,*.mov
set wig+=*.jpg,*.png,*.gif,*.bmp,*.xcf,*.psd,*.ai,*.svg
set wig+=*.svn,.git/*
set wig+=*.tar,*.gz,*.rar,*.zip,*.iso

" command-line completion shows a list of matches
" wildmenu set (nowmnu|wmnu)
set	wmnu
" }}}

" {{{ 25 multi-byte characters
" fileencodings
" automatically detected character encodings
set fencs=ucs-bom,utf-8,latin1,cp80,default
" }}}

" {{{ MRU plugin
let MRU_Max_Entries = 400
map <leader>r :MRU<CR>
" }}}

" {{{ 26 various
" viminfo list that specifies what to write in the viminfo file
set vi='100,<50,s10,h,!
" }}}

" {{{ Command-T
noremap <leader>j :CommandT<cr>
noremap <leader>y :CommandTFlush<cr>
" }}}

" {{{ Jump to last position of buffer when opening
au BufReadPost * if line("'\"") > 0 && line("'\"") <= line("$") | exe "normal g'\"" | endif
" }}}

" {{{ Nerd Tree
silent! nmap <silent> <Leader>p :NERDTreeToggle<CR>
nnoremap <silent> <C-f> :call FindInNERDTree()<CR>
" }}}

" {{{ Enabling Zencoding
let g:user_zen_settings = {
	\ 'php'  : {'extends' : 'html', 'filters' : 'c'},
	\ 'xml'  : {'extends' : 'html'},
	\ 'haml' : {'extends' : 'html'},
	\ 'erb'  : {'extends' : 'html'},
\}
" }}}

" {{{ Shortcuts for tabs
map <leader>tn :tabnew 
map <leader>tf :tabfirst<cr>
map <leader>tc :tabclose<cr>
map <leader>tm :tabmove 
map <leader>tg :tabn 

nmap <tab> gt
nmap <s-tab> gT
" }}}

" {{{ Sane movement with wrap turned on
nnoremap j gj
nnoremap k gk
vnoremap j gj
vnoremap k gk
" }}}

" {{{do not menu with left / right in command line
cnoremap <Left> <Space><BS><Left>
cnoremap <Right> <Space><BS><Right>
" }}}

" {{{ Easy indentation and bunbble
" indentation multiple lines
vmap <C-Right> >gv
vmap <C-Left> <gv

" indentation single lines
nmap <C-Right> >>
nmap <C-Left> <<

" Bubble single lines
nmap <C-Up> ddkP
nmap <C-Down> ddp

" Bubble multiple lines
vmap <C-Up> xkP`[V`]
vmap <C-Down> xp`[V`]
" }}}

" {{{ Abbreviations for your sanity
cab W w
cab Q q
cab E e
cab Wq wq
cab wQ wq
cab WQ wq
" }}}

" {{{ Key mapping for window navigation
map <C-h> <C-w>h
map <C-j> <C-w>j
map <C-k> <C-w>k
map <C-l> <C-w>l
" }}}

" {{{ Camel case motion
map <S-W> <Plug>CamelCaseMotion_w
map <S-B> <Plug>CamelCaseMotion_b
map <S-E> <Plug>CamelCaseMotion_e
" }}}

" {{{ Visual search mappings
function! s:VSetSearch()
	let temp = @@
	norm! gvy
	let @/ = '\V' . substitute(escape(@@, '\'), '\n', '\\n', 'g')
	let @@ = temp
endfunction

vnoremap * :<C-u>call <SID>VSetSearch()<CR>//<CR>
vnoremap # :<C-u>call <SID>VSetSearch()<CR>??<CR>
" }}}

" {{{ define :HighlightLongLines command to highlight the offending parts of
" lines that are longer than the specified length (defaulting to 80)
command! -nargs=? HighlightLongLines call s:HighlightLongLines('<args>')
function! s:HighlightLongLines(width)
	let targetWidth = a:width != '' ? a:width : 79
	if targetWidth > 0
		exec 'match Todo /\%>' . (targetWidth) . 'v/'
	else
		echomsg "Usage: HighlightLongLines [natural number]"
	endif
endfunction
map <leader>hl :HighlightLongLines
" }}}

" vim: set foldmethod=marker :
